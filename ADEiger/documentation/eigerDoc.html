<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
        "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xml:lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title>areaDetector Eiger driver</title>
  <meta content="text/html; charset=ISO-8859-1" http-equiv="Content-Type" />
</head>
<body>
  <div style="text-align: center">
    <h1>
      areaDetector Eiger driver</h1>
    <h2>
      December 13, 2018</h2>
    <h2>
      Bruno Martins<br />
      Diego Omitto<br />
      Mark Rivers</h2>
  </div>
  <h2>
    Table of Contents</h2>
  <ul>
    <li><a href="#Introduction">Introduction</a></li>
    <li><a href="#Trigger_Modes">Trigger Modes</a></li>
    <li><a href="#Manual_Trigger">Manual Trigger</a></li>
    <li><a href="#Data_Acquisition">Data Acquisition</a>
      <ul>
        <li><a href="#Using_FileWriter">Using FileWriter</a></li>
        <li><a href="#Using_Stream">Using Stream</a></li>
        <li><a href="#Using_Monitor">Using Monitor</a></li>
      </ul>
    </li>
    <li><a href="#StandardNotes">Implementation of standard driver parameters</a></li>
    <li><a href="#Driver_parameters">Eiger specific parameters</a></li>
    <li><a href="#Unsupported">Unsupported standard driver parameters</a></li>
    <li><a href="#Configuration">Configuration</a></li>
    <li><a href="#CSS_screen">CSS screen</a></li>
    <li><a href="#Known_Issues">Known Issues</a>
      <ul>
        <li><a href="#Changing_the_Photon_Energy">Changing the Photon Energy</a></li>
        <li><a href="#Status_Parameters_Polling">Status Parameters Polling</a></li>
        <li><a href="#Internal_Enable_Mode">Internal Enable Mode</a></li>
      </ul>
    </li>
  </ul>
  <h2 id="Introduction" style="text-align: left">
    Introduction</h2>
  <p>
    This is an <a href="http://www.aps.anl.gov/epics">EPICS</a> <a href="areaDetector.html">
      areaDetector</a> driver for the Eiger detector from <a href="http://www.dectris.com">
        Dectris</a>. It has been tested on the Eiger 500K, 1M, 4M and 16M with the firmware
    version 1.6.4+. The driver communicates with the detector via its SIMPLON REST interface,
    so no library from Dectris is required. The images can pulled from the detector
    as HDF5 files, as a ZeroMQ stream or both. The files can be both saved to disk and
    passed to the areaDetector pipeline at the same time.
  </p>
  <p>
    All trigger modes are supported, although Internal Enable mode seems to not be working
    properly. See <a href="#Internal_Enable_Mode">Known Issues</a>.</p>
  <p>
    This driver inherits from <a href="areaDetectorDoc.html#ADDriver">ADDriver</a>.
    It implements many of the parameters in <a href="areaDetectorDoxygenHTML/asyn_n_d_array_driver_8h.html">
      asynNDArrayDriver.h</a> and in <a href="areaDetectorDoxygenHTML/_a_d_driver_8h.html">
        ADArrayDriver.h</a>. It also implements a number of parameters that are specific
    to the Eiger detector. The <a href="areaDetectorDoxygenHTML/classeiger_detector.html">
      eigerDetector class documentation</a> describes this class in detail.
  </p>
  <p>
    This document does not attempt to explain the meaning of the Eiger-specific parameters,
    as they are explained in the SIMPLON API Reference and in the EIGER Detector Manual
    documents from Dectris. Sometimes it does, however, refer to those parameters as
    they are named in Dectris' documentation.
  </p>
  <p>
    The SIMPLON API provides ways to query parameter limits, valid values for enums,
    error conditions, etc. The driver will clamp values to their minumum or maximum
    value if they are outside the acceptable range. Setting a parameter will immediately
    push its value to the detector.
  </p>
  <p>
    This driver was built upon a multithreaded architecture. A combination of threads
    is used to simultaneously pull files from the detector, save them to disk and parse
    them into NDArrays. A dedicated thread is used to receive images in a ZeroMQ stream.
  </p>
  <p>
    A few Eiger parameters are set at IOC initialization time and are expected to not
    change. Namely:
  </p>
  <ul>
    <li>detector/config/auto_summation = true</li>
    <li>filewriter/config/image_nr_start = 1</li>
    <li>monitor/config/buffer_size = 1</li>
  </ul>
  <h2 id="Accessing_New_Parameters">
    Accessing New Parameters</h2>
  <p>
    Some parameters are not relevant to the driver operation and as such are not exposed
    initially by the driver as PVs. However, there is a mechanism to access other parameters
    not created automatically by the driver by simply instantiating new records with
    the appropriate <code>drvInfo</code> string. Some of the PVs are created this way.
    For example, the PV XPixelSize_RBV has the following <code>drvInfo</code>:</p>
  <pre>EIG_DCD_x_pixel_size</pre>
  <p>
    For those parameters, the first four characters must be <code>EIG_</code>. Then
    the fifth character must be one of:</p>
  <ul>
    <li><code>D</code>: Detector subsystem</li>
    <li><code>M</code>: Monitor subsystem</li>
    <li><code>F</code>: FileWriter subsystem</li>
    <li><code>S</code>: Stream subsystem</li>
  </ul>
  <p>
    The sixth character determines if the parameter is a configuration or a status parameter:</p>
  <ul>
    <li><code>C</code>: Configuration</li>
    <li><code>S</code>: Status</li>
  </ul>
  <p>
    The seventh character determines which asyn parameter type to use:</p>
  <ul>
    <li><code>I</code>: Integer (<code>asynParamInt32</code>)</li>
    <li><code>D</code>: Double (<code>asynParamFloat64</code>)</li>
    <li><code>S</code>: String (<code>asynParamOctet</code>)</li>
  </ul>
  <p>
    The eighth character must be a <code>_</code>, and the remaining characters are
    the parameter's name according to the SIMPLON API Manual. Hence, for this example,
    this PV will be accessing the parameter:</p>
  <pre>detector/api/&lt;version&gt;/config/x_pixel_size</pre>
  <h2 id="Trigger_Modes">
    Trigger Modes</h2>
  <p>
    There are four trigger modes available:</p>
  <ul>
    <li><b>Internal Series</b>: one internal trigger pulse generates N images </li>
    <li><b>Internal Enable</b>: one internal trigger pulse generates one image</li>
    <li><b>External Series</b>: one external trigger pulse generates N images</li>
    <li><b>External Enable</b>: one external trigger pulse generates one image</li>
  </ul>
  <p>
    The total number of images generated by <b>Internal</b> and <b>External Series</b>
    modes is given by the product of the NumImages and NumTriggers PVs (<i>nimages</i>
    and <i>ntriggers</i> in Dectris terminology).
  </p>
  <p>
    On both <b>Internal</b> and <b>External Enable</b> modes the total number of images
    generated is given solely by the NumTriggers PV (<i>ntriggers</i>). NumImages is
    set to 1 temporarily during the acquisition.
  </p>
  <p>
    Triggers for <b>Internal Enable</b> mode are sent by processing the Trigger PV.
    The exposure for each individual image is given by the TriggerExposure PV and can
    change between triggers in the same acquisition. This mode is experimental as of
    firmware 1.5.0. See Known Issues.
  </p>
  <h2 id="Manual_Trigger">
    Manual Trigger</h2>
  <p>
    On <b>Internal Series</b> and <b>Internal Enable</b> modes, if the ManualTrigger
    PV is set to YES, the triggers are not auto generated by the driver. Instead, they
    are sent by processing the Trigger PV. On <b>Internal Enable</b> mode the trigger
    carries an exposure value that can change for each trigger, which is set by the
    TriggerExposure PV. Note that the <b>Internal Enable</b> mode is experimental as
    of firmware 1.5.0, see Known Issues.
  </p>
  <h2 id="Data_Acquisition">
    Data Acquisition</h2>
  <p>
    Data generated by the Eiger can be pulled from the detector in a number of ways.
    The detector has three modules (in Dectris' terminology) that make the results of
    the acquisition available in different ways. The <b>FileWriter </b>module writes
    the generated images to the detector disk as HDF5 files that consist of a master
    (header) file and a number of data files. The <b>Stream</b> module makes the images
    available as soon as they are captured as a ZeroMQ stream. The <b>Monitor</b> module
    produces TIFF images every so often to monitor how a long acquisition is progressing.
  </p>
  <p>
    Data from the FileWriter or from the Stream mode can be parsed into NDArrays for
    the areaDetector pipeline. The actual source is selected with the DataSource PV.
    If DataSource is set to None, however, no data will be sent to the areaDetector
    pipeline but the detector will still be controllable via the areaDetector driver;
    third-party clients can then pull files or listen to the ZeroMQ stream independently
    of this driver.
  </p>
  <h3 id="Using_FileWriter">
    Using FileWriter</h3>
  <p>
    The FileWriter module is activated when FWEnable is set to Yes. Files generated
    by the FileWriter have names according to the FWNamePattern PV. The default pattern
    is "series_$id", where $id is replaced by the Sequence ID of the acquisition. A
    master file is generated as soon as the detector is successfully armed. A number
    of data files follow. The number of data files generated depends on the total number
    of images of the acquisition and the FWNFilesPerImage PV.
  </p>
  <p>
    For example, if TriggerMode is <b>External Enable</b>, NumImages is 60, NumTriggers
    is 2, FWNImagesPerFile is 100, Sequence ID for the acquisition is 1 and FWNamePattern
    is "series_$id", a total of three files will be generated:</p>
  <ul>
    <li>series_1_master.h5</li>
    <li>series_1_data_000001.h5 (with 100 images)</li>
    <li>series_1_data_000002.h5 (with 20 images)</li>
  </ul>
  <p>
    The generated files will be downloaded either if DataSource is set to FileWriter
    or if SaveFiles is set to Yes. Files are downloaded as soon as they are available.
    To determine if a file is available the driver polls the detector at a nominal rate
    of 10Hz. While a file is being processed the next file available is downloaded in
    parallel. All files will remain on the detector disk unless FWAutoRemove is set
    to Yes.
  </p>
  <p>
    When saving files to disk (SaveFiles = Yes) it is possible to set the file's owner,
    its group and its access permissions with FileOwner, FileOwnerGrp and FilePerms
    PVs. To be able to set arbitrary owners the IOC executable requires CAP_SETUID and
    CAP_SETGID capabilities, which can be given with the command:</p>
  <pre>sudo setcap cap_setuid,cap_setgid+ep eigerDetectorApp</pre>
  <p>
    All files on the detector disk can be deleted at once by processing the FWClear
    PV.
  </p>
  <p>
    If the last data file of a series won't be full (e.g. series_1_data_000002.h5 with
    20 images) then it will only appear on the detector disk after a disarm command
    (issued when the acquisition is stopped), which flushes the FileWriter buffer.
  </p>
  <h3 id="Using_Stream">
    Using Stream</h3>
  <p>
    The Stream module is activated when StreamEnable is set to Yes. Data will then be
    available on the detector's tcp port 9999 as a ZMQ_PUSH socket. If DataSource is
    set to Stream, this driver opens a corresponding ZMQ_PULL socket and parses the
    incoming data as NDArrays. Otherwise a third-party client can listen on that socket
    for data. The format of the packets is specified in the Eiger SIMPLON API documentation.
  </p>
  <h3 id="Using_Monitor">
    Using Monitor</h3>
  <p>
    The Monitor module is activated when MonitorEnable is set to Yes. Data will be available
    whenever the monitor module buffer is full (has one image available). This driver
    waits MonitorTimeout ms for data to be available. There is a rate-limit of 10Hz.
    Once downloaded, the TIFF image is parsed into areaDetector's NDArray on NDArrayAddr
    1 (therefore, an independent NDArray stream).
  </p>
  <h2 id="Crystallography_Parameters">
    Chrystallography Parameters</h2>
  <p>
    A few parameters are available as metadata for the acquisition. These values are
    stored on the master file and sent as metadata in ZeroMQ stream, but otherwise don't
    affect the acquisition, with the exception of the Wavelength parameter, which sets
    Photon Energy accordingly.
  </p>
  <h2 id="StandardNotes" style="text-align: left">
    Implementation of standard driver parameters</h2>
  <p>
    The following table describes how the Eiger driver implements some of the standard
    driver parameters.
  </p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="4">
          <b>Implementation of Parameters in asynNDArrayDriver.h and ADDriver.h, and EPICS Record
            Definitions in ADBase.template and NDFile.template</b></td>
      </tr>
      <tr>
        <th>
          Parameter index variable
        </th>
        <th>
          EPICS record name
        </th>
        <th>
          Eiger Parameter
        </th>
        <th>
          Description
        </th>
      </tr>
      <tr>
        <td>
          ADTriggerMode</td>
        <td>
          $(P)$(R)TriggerMode<br />
          $(P)$(R)TriggerMode_RBV</td>
        <td>
          detector/config/trigger_mode</td>
        <td>
          Sets the trigger mode for the detector. Options are:
          <ul>
            <li>Internal Series</li>
            <li>Internal Enable</li>
            <li>External Series</li>
            <li>External Enable</li>
          </ul>
        </td>
      </tr>
      <tr>
        <td>
          ADNumImages</td>
        <td>
          $(P)$(R)NumImages<br />
          $(P)$(R)NumImages_RBV </td>
        <td>
          detector/config/nimages</td>
        <td>
          Sets the number of images to take per trigger when on Internal Series or External
          Series mode.</td>
      </tr>
      <tr>
        <td>
          ADAcquireTime</td>
        <td>
          $(P)$(R)AcquireTime<br />
          $(P)$(R)AcquireTime_RBV </td>
        <td>
          detector/config/count_time</td>
        <td>
          Sets the parameter "count_time", which is the exposure time for a single image on
          INTS or EXTS mode. </td>
      </tr>
      <tr>
        <td>
          ADAcquirePeriod</td>
        <td>
          $(P)$(R)AcquirePeriod<br />
          $(P)$(R)AcquirePeriod_RBV </td>
        <td>
          detector/config/frame_time</td>
        <td>
          Sets the parameter "frame_time", which directly affects the frame rate of the detector.
          The resulting frame rate will be 1/AcquirePeriod. </td>
      </tr>
      <tr>
        <td>
          NDDataType</td>
        <td>
          $(P)$(R)DataType_RBV</td>
        <td>
        </td>
        <td>
          The data type of the image data. If AcquireTime results in less than 50Hz, this
          will have the value UInt16, otherwise UInt32. </td>
      </tr>
      <tr>
        <td>
          ADTemperatureActual</td>
        <td>
          $(P)$(R)TemperatureActual</td>
        <td>
          detector/status/board_000/th0_temp</td>
        <td>
          Reads the actual temperature of the detector.</td>
      </tr>
      <tr>
        <td>
          ADMaxSizeX</td>
        <td>
          $(P)$(R)MaxSizeX_RBV</td>
        <td>
        </td>
        <td>
          Detector sensor size in the X direction.</td>
      </tr>
      <tr>
        <td>
          ADMaxSizeY</td>
        <td>
          $(P)$(R)MaxSizeY_RBV</td>
        <td>
        </td>
        <td>
          Detector sensor size in the Y direction.</td>
      </tr>
      <tr>
        <td>
          NDArraySizeX</td>
        <td>
          $(P)$(R)ArraySizeX_RBV</td>
        <td>
          detector/config/x_pixels_in_detector</td>
        <td>
          Current detector sensor size in the X direction. This can change depending on the
          ROI Mode selected. </td>
      </tr>
      <tr>
        <td>
          NDArraySizeY</td>
        <td>
          $(P)$(R)ArraySizeY_RBV</td>
        <td>
          detector/config/y_pixels_in_detector</td>
        <td>
          Current detector sensor size in the Y direction. This can change depending on the
          ROI Mode selected. </td>
      </tr>
      <tr>
        <td>
          ADManufacturer<br />
          ADModel</td>
        <td>
          $(P)$(R)Manufacturer_RBV<br />
          $(P)$(R)Model_RBV</td>
        <td>
          detector/config/description</td>
        <td>
          Reads the detector manufacturer (Dectris) and model (Eiger xx M).</td>
      </tr>
      <tr>
        <td>
          ADSerialNumber</td>
        <td>
          $(P)$(R)SerialNumber_RBV</td>
        <td>
          detector/config/detector_number</td>
        <td>
          Detector serial number</td>
      </tr>
      <tr>
        <td>
          ADFirmwareVersion</td>
        <td>
          $(P)$(R)FirmwareVersion_RBV </td>
        <td>
          detector/config/software_version</td>
        <td>
          Detector firmware version</td>
      </tr>
      <tr>
        <td>
          NDDriverVersion</td>
        <td>
          $(P)$(R)DriverVersion_RBV </td>
        <td>
        </td>
        <td>
          This driver's version</td>
      </tr>
    </tbody>
  </table>
  <h2 id="Driver_parameters" style="text-align: left">
    Eiger specific parameters</h2>
  <p>
    The Eiger driver implements the following parameters in addition to those in asynNDArrayDriver.h
    and ADDriver.h.
  </p>
  <table border="1" cellpadding="2" cellspacing="2" style="text-align: left">
    <tbody>
      <tr>
        <td align="center" colspan="8">
          <b>Parameter Definitions in eigerDetector.cpp and EPICS Record Definitions in eiger.template</b>
        </td>
      </tr>
      <tr>
        <th>
          Parameter index variable
        </th>
        <th>
          Eiger Parameter
        </th>
        <th>
          asyn interface
        </th>
        <th>
          Access
        </th>
        <th>
          Description
        </th>
        <th>
          drvInfo string
        </th>
        <th>
          EPICS record name
        </th>
        <th>
          EPICS record type
        </th>
      </tr>
      <tr>
        <td align="center" colspan="8">
          <b>Detector Metadata</b> </td>
      </tr>
      <tr>
        <td>
          EigerDescription</td>
        <td>
          detector/config/description</td>
        <td>
          asynOctet</td>
        <td>
          R/O</td>
        <td>
          Detector's manufacturer and model</td>
        <td>
          DESCRIPTION</td>
        <td>
          Description_RBV</td>
        <td>
          stringin</td>
      </tr>
      <tr>
        <td>
          EigerSensorMaterial</td>
        <td>
          detector/config/sensor_material</td>
        <td>
          asynOctet</td>
        <td>
          R/O</td>
        <td>
          Detector's sensor material</td>
        <td>
          EIG_DCD_sensor_material</td>
        <td>
          SensorMaterial_RBV</td>
        <td>
          stringin</td>
      </tr>
      <tr>
        <td>
          EigerSensorThickness</td>
        <td>
          detector/config/sensor_thickness</td>
        <td>
          asynFloat64</td>
        <td>
          R/O</td>
        <td>
          Detector's sensor thickness, in meters</td>
        <td>
          EIG_DCD_sensor_thickness</td>
        <td>
          SensorThickness_RBV</td>
        <td>
          ai</td>
      </tr>
      <tr>
        <td>
          EigerXPixelSize</td>
        <td>
          detector/config/x_pixel_size</td>
        <td>
          asynFloat64</td>
        <td>
          R/O</td>
        <td>
          Detector's pixel size in the X direction, in meters</td>
        <td>
          EIG_DCD_x_pixel_size</td>
        <td>
          XPixelSize_RBV</td>
        <td>
          ai</td>
      </tr>
      <tr>
        <td>
          EigerYPixelSize</td>
        <td>
          detector/config/y_pixel_size</td>
        <td>
          asynFloat64</td>
        <td>
          R/O</td>
        <td>
          Detector's pixel size in the Y direction, in meters</td>
        <td>
          EIG_DCD_y_pixel_size</td>
        <td>
          YPixelSize_RBV</td>
        <td>
          ai</td>
      </tr>
      <tr>
        <td>
          EigerDeadTime</td>
        <td>
          detector/config/detector_readout_time</td>
        <td>
          asynFloat64</td>
        <td>
          R/O</td>
        <td>
          Detector's readout time (dead time) between frames. Changes with different Threshold
          Energies.</td>
        <td>
          EIG_DCD_detector_readout_time</td>
        <td>
          DeadTime_RBV</td>
        <td>
          ai</td>
      </tr>
      <tr>
        <td align="center" colspan="8">
          <b>Status parameters</b> </td>
      </tr>
      <tr>
        <td>
          EigerState</td>
        <td>
          detector/status/state</td>
        <td>
          asynOctet</td>
        <td>
          R/O</td>
        <td>
          State of the detector</td>
        <td>
          STATE</td>
        <td>
          State_RBV</td>
        <td>
          stringin</td>
      </tr>
      <tr>
        <td>
          EigerError</td>
        <td>
          detector/status/error</td>
        <td>
          asynOctet</td>
        <td>
          R/O</td>
        <td>
          List of parameters causing an error state</td>
        <td>
          ERROR</td>
        <td>
          Error_RBV</td>
        <td>
          stringin</td>
      </tr>
      <tr>
        <td>
          EigerDCUBufferFree</td>
        <td>
          detector/status/builder/dcu_buffer_free</td>
        <td>
          asynFloat64</td>
        <td>
          R/O</td>
        <td>
          Percentage of the detector's internal buffer that is free. Low values may indicate
          a problem.</td>
        <td>
          DCU_BUF_FREE</td>
        <td>
          DCUBufferFree_RBV</td>
        <td>
          ai</td>
      </tr>
      <tr>
        <td>
          EigerThTemp0</td>
        <td>
          detector/status/board_000/th0_temp</td>
        <td>
          asynFloat64</td>
        <td>
          R/O</td>
        <td>
          Temperature of the first module</td>
        <td>
          TH_TEMP_0</td>
        <td>
          Temp0_RBV</td>
        <td>
          ai</td>
      </tr>
      <tr>
        <td>
          EigerThHumid0</td>
        <td>
          detector/status/board_000/th0_humidity</td>
        <td>
          asynFloat64</td>
        <td>
          R/O</td>
        <td>
          Humidity of the first module</td>
        <td>
          TH_HUMID_0</td>
        <td>
          Humid0_RBV</td>
        <td>
          ai</td>
      </tr>
      <tr>
        <td>
          EigerLink0<br />
          EigerLink1<br />
          EigerLink2<br />
          EigerLink3</td>
        <td>
          detector/status/link_0<br />
          detector/status/link_1<br />
          detector/status/link_2<br />
          detector/status/link_3</td>
        <td>
          asynInt32</td>
        <td>
          R/O</td>
        <td>
          Status of the four links between the detector server and the head</td>
        <td>
          LINK_0<br />
          LINK_1<br />
          LINK_2<br />
          LINK_3</td>
        <td>
          Link0_RBV<br />
          Link1_RBV<br />
          Link2_RBV<br />
          Link3_RBV</td>
        <td>
          bi</td>
      </tr>
      <tr>
        <td align="center" colspan="8">
          <b>FileWriter control</b> </td>
      </tr>
      <tr>
        <td>
          EigerFWEnable</td>
        <td>
          filewriter/config/mode</td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Enables or disables the FileWriter module</td>
        <td>
          FW_ENABLE</td>
        <td>
          FWEnable<br />
          FWEnable_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          EigerFWClear</td>
        <td>
          filewriter/config/clear</td>
        <td>
          asynInt32</td>
        <td>
          W/O</td>
        <td>
          Writing to this PV clears *all* files on the detector server disk</td>
        <td>
          CLEAR</td>
        <td>
          FWClear</td>
        <td>
          ao</td>
      </tr>
      <tr>
        <td>
          EigerFWCompression</td>
        <td>
          filewriter/config/compression_enabled</td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Enables or disables LZ4 or BSLZ4 compression on the server side </td>
        <td>
          COMPRESSION</td>
        <td>
          FWCompression<br />
          FWCompression_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          EigerFWNamePattern</td>
        <td>
          filewriter/config/name_patttern</td>
        <td>
          asynOctet</td>
        <td>
          R/W</td>
        <td>
          Name pattern for the generated HDF5 files. The pattern can be anything, but it must
          contain the string '$id' in it. This string is replaced with the current sequence
          id of the acquisition. The default is: "series_$id", which would generate the files:<br />
          <ul>
            <li>series_1_master.h5</li>
            <li>series_1_data_000001.h5</li>
            <li>series_1_data_000002.h5</li>
            <li>...</li>
          </ul>
          For the sequence id 1. If '$id' is omitted, files might get overwritten on the server,
          because then every acqusition would generate files with the same name </td>
        <td>
          NAME_PATTERN</td>
        <td>
          FWNamePattern<br />
          FWNamePattern_RBV</td>
        <td>
          stringout<br />
          stringin</td>
      </tr>
      <tr>
        <td>
          EigerFWNImagesPerFile</td>
        <td>
          filewriter/config/nimages_per_file</td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Number of images per HDF5 data file </td>
        <td>
          NIMAGES_PER_FILE</td>
        <td>
          FWNImgsPerFile<br />
          FWNImgsPerFile_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerFWAutoRemove</td>
        <td>
        </td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Controls whether downloaded files should be removed from the detector disk </td>
        <td>
          AUTO_REMOVE</td>
        <td>
          FWAutoRemove<br />
          FWAutoRemove_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          EigerFWFree</td>
        <td>
          filewriter/status/buffer_free</td>
        <td>
          asynFloat64</td>
        <td>
          R/O</td>
        <td>
          Free space on detector disk.</td>
        <td>
          FW_FREE</td>
        <td>
          FWFree_RBV</td>
        <td>
          ai</td>
      </tr>
      <tr>
        <td>
          EigerFWState</td>
        <td>
          filewriter/status/state</td>
        <td>
          asynOctet</td>
        <td>
          R/O</td>
        <td>
          State of the FileWriter module</td>
        <td>
          FW_STATE</td>
        <td>
          FWState_RBV</td>
        <td>
          stringin</td>
      </tr>
      <tr>
        <td align="center" colspan="8">
          <b>Stream control</b> </td>
      </tr>
      <tr>
        <td>
          EigerStreamEnable</td>
        <td>
          stream/config/mode</td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Enables or disables the Stream module</td>
        <td>
          STREAM_ENABLE</td>
        <td>
          StreamEnable<br />
          StreamEnable_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          EigerStreamDropped</td>
        <td>
          stream/status/dropped</td>
        <td>
          asynInt32</td>
        <td>
          R/O</td>
        <td>
          Indicates how many images were dropped in the last acquisition</td>
        <td>
          STREAM_DROPPED</td>
        <td>
          StreamDropped_RBV</td>
        <td>
          ai</td>
      </tr>
      <tr>
        <td>
          EigerStreamDecompress</td>
        <td>
          N.A.</td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Controls whether the NDArrays from the Stream interface are decompressed (Yes) or
          compressed (No)</td>
        <td>
          STREAM_DECOMPRES</td>
        <td>
          StreamDecompress<br />
          StreamDecompress_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          EigerStreamState</td>
        <td>
          stream/status/state</td>
        <td>
          asynOctet</td>
        <td>
          R/O</td>
        <td>
          State of the Stream module</td>
        <td>
          STREAM_STATE</td>
        <td>
          StreamState_RBV</td>
        <td>
          stringin</td>
      </tr>
      <tr>
        <td>
        </td>
        <td>
          stream/config/header_detail</td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Selects the level of detail for Stream API Headers. Options are:
          <ul>
            <li>All</li>
            <li>Basic</li>
            <li>None</li>
          </ul>
        </td>
        <td>
          EIG_SCI_header_detail</td>
        <td>
          StreamHdrDetail<br />
          StreamHdrDetail_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
      </tr>
      <tr>
        <td>
        </td>
        <td>
          stream/config/header_appendix</td>
        <td>
          asynOctet</td>
        <td>
          R/W</td>
        <td>
          Sets the text to be appended to the Stream API headers </td>
        <td>
          EIG_SCS_header_appendix</td>
        <td>
          StreamHdrAppendix</td>
        <td>
          waveform</td>
      </tr>
      <tr>
        <td>
        </td>
        <td>
          stream/config/image_appendix</td>
        <td>
          asynOctet</td>
        <td>
          R/W</td>
        <td>
          Sets the text to be appended to the Stream API images </td>
        <td>
          EIG_SCS_image_appendix</td>
        <td>
          StreamImgAppendix</td>
        <td>
          waveform</td>
      </tr>
      <tr>
        <td align="center" colspan="8">
          <b>Monitor control</b> </td>
      </tr>
      <tr>
        <td>
          EigerMonitorEnable</td>
        <td>
          monitor/config/mode</td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Enables or disables the Monitor module</td>
        <td>
          MONITOR_ENABLE</td>
        <td>
          MonitorEnable<br />
          MonitorEnable_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          EigerMonitorTimeout</td>
        <td>
        </td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Timeout for queries on the Monitor interface for new images</td>
        <td>
          MONITOR_TIMEOUT</td>
        <td>
          MonitorTimeout<br />
          MonitorTimeout_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerMonitorState</td>
        <td>
          monitor/status/state</td>
        <td>
          asynOctet</td>
        <td>
          R/O</td>
        <td>
          State of the Monitor module</td>
        <td>
          MONITOR_STATE</td>
        <td>
          MonitorState_RBV</td>
        <td>
          stringin</td>
      </tr>
      <tr>
        <td align="center" colspan="8">
          <b>Acquisition metadata</b> </td>
      </tr>
      <tr>
        <td>
          EigerBeamX</td>
        <td>
          detector/config/beam_center_x</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          X position of the beam </td>
        <td>
          EIG_DCD_beam_center_x</td>
        <td>
          BeamX<br />
          BeamX_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerBeamY</td>
        <td>
          detector/config/beam_center_y</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Y position of the beam </td>
        <td>
          EIG_DCD_beam_center_y</td>
        <td>
          BeamY<br />
          BeamY_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerDetDist</td>
        <td>
          detector/config/detector_distance</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Detector distance </td>
        <td>
          EIG_DCD_detector_distance</td>
        <td>
          DetDist<br />
          DetDist_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerWavelength</td>
        <td>
          detector/config/wavelength</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Wavelength of the beam. This parameter is automatically changed whenever the PhotonEnergy
          changes </td>
        <td>
          WAVELENGTH</td>
        <td>
          Wavelength<br />
          Wavelength_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerCountCutoff</td>
        <td>
          detector/config/countrate_correction_count_cutoff</td>
        <td>
          asynInt32</td>
        <td>
          R/O</td>
        <td>
          Number of counts after which the detector will cutoff due to the count rate correction.
        </td>
        <td>
          EIG_DCI_countrate_correction_count_cutoff</td>
        <td>
          CountCutoff_RBV</td>
        <td>
          ai</td>
      </tr>
      <tr>
        <td align="center" colspan="8">
          <b>Acquisition MX metadata</b> </td>
      </tr>
      <tr>
        <td>
          EigerChiStart</td>
        <td>
          detector/config/chi_start</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Start value of the Chi angle </td>
        <td>
          EIG_DCD_chi_start</td>
        <td>
          ChiStart<br />
          ChiStart_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerChiIncr</td>
        <td>
          detector/config/chi_increment</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Chi angle increment per frame </td>
        <td>
          EIG_DCD_chi_increment</td>
        <td>
          ChiIncr<br />
          ChiIncr_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerKappaStart</td>
        <td>
          detector/config/kappa_start</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Start value of the Kappa angle </td>
        <td>
          EIG_DCD_kappa_start</td>
        <td>
          KappaStart<br />
          KappaStart_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerKappaIncr</td>
        <td>
          detector/config/kappa_increment</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Kappa angle increment per frame </td>
        <td>
          EIG_DCD_kappa_increment</td>
        <td>
          KappaIncr<br />
          KappaIncr_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerOmegaStart</td>
        <td>
          detector/config/omega_start</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Start value of the Omega angle </td>
        <td>
          EIG_DCD_omega_start</td>
        <td>
          OmegaStart<br />
          OmegaStart_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerOmegaIncr</td>
        <td>
          detector/config/omega_increment</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Omega angle increment per frame </td>
        <td>
          EIG_DCD_omega_increment</td>
        <td>
          OmegaIncr<br />
          OmegaIncr_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerPhiStart</td>
        <td>
          detector/config/phi_start</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Start value of the Phi angle </td>
        <td>
          EIG_DCD_phi_start</td>
        <td>
          PhiStart<br />
          PhiStart_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerPhiIncr</td>
        <td>
          detector/config/phi_increment</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Phi angle increment per frame </td>
        <td>
          EIG_DCD_phi_increment</td>
        <td>
          PhiIncr<br />
          PhiIncr_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerTwoThetaStart</td>
        <td>
          detector/config/two_theta_start</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Start value of the TwoTheta angle </td>
        <td>
          EIG_DCD_two_theta_start</td>
        <td>
          TwoThetaStart<br />
          TwoThetaStart_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerTwoThetaIncr</td>
        <td>
          detector/config/two_theta_increment</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          TwoTheta angle increment per frame </td>
        <td>
          EIG_DCD_two_theta_increment</td>
        <td>
          TwoThetaIncr<br />
          TwoThetaIncr_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td align="center" colspan="8">
          <b>Acquisition control</b> </td>
      </tr>
      <tr>
        <td>
          EigerDataSource</td>
        <td>
        </td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Which data source to use for areaDetecor pipeline. Valid values:
          <ul>
            <li>None</li>
            <li>FileWriter</li>
            <li>Stream</li>
          </ul>
        </td>
        <td>
          DATA_SOURCE</td>
        <td>
          DataSource<br />
          DataSource_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
      </tr>
      <tr>
        <td>
          EigerArmed</td>
        <td>
        </td>
        <td>
          asynInt32</td>
        <td>
          R/O</td>
        <td>
          Armed state of the detector </td>
        <td>
          ARMED</td>
        <td>
          Armed</td>
        <td>
          bi</td>
      </tr>
      <tr>
        <td>
          EigerSaveFiles</td>
        <td>
        </td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Controls whether acquired files should be saved locally to disk </td>
        <td>
          SAVE_FILES</td>
        <td>
          SaveFiles<br />
          SaveFiles_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          EigerFileOwner</td>
        <td>
        </td>
        <td>
          asynOctet</td>
        <td>
          R/W</td>
        <td>
          Controls the owner of the file saved to disk. Requires the IOC to have the CAP_SETUID
          capability. </td>
        <td>
          FILE_OWNER</td>
        <td>
          FileOwner<br />
          FileOwner_RBV</td>
        <td>
          stringout<br />
          stringin</td>
      </tr>
      <tr>
        <td>
          EigerFileOwnerGroup</td>
        <td>
        </td>
        <td>
          asynOctet</td>
        <td>
          R/W</td>
        <td>
          Controls the owner group of the file saved to disk. Requires the IOC to have the
          CAP_SETGID capability. </td>
        <td>
          FILE_OWNER_GROUP</td>
        <td>
          FileOwnerGrp<br />
          FileOwnerGrp_RBV</td>
        <td>
          stringout<br />
          stringin</td>
      </tr>
      <tr>
        <td>
          EigerFilePerms</td>
        <td>
        </td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Controls the permissions for the files saved to disk </td>
        <td>
          FILE_PERMISSIONS</td>
        <td>
          FilePerms</td>
        <td>
          ao</td>
      </tr>
      <tr>
        <td>
          EigerSequenceId</td>
        <td>
        </td>
        <td>
          asynInt32</td>
        <td>
          R/O</td>
        <td>
          Sequence ID of the current acquisition</td>
        <td>
          SEQ_ID</td>
        <td>
          SequenceId</td>
        <td>
          ai</td>
      </tr>
      <tr>
        <td>
          EigerFlatfield</td>
        <td>
          detector/config/flatfield_correction_applied</td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Controls whether the flatfield correction should be applied </td>
        <td>
          EIG_DCI_flatfield_correction_applied</td>
        <td>
          FlatfieldApplied<br />
          FlatfieldApplied_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          EigerPhotonEnergy</td>
        <td>
          detector/config/photon_energy</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Photon energy for the acquisition </td>
        <td>
          PHOTON_ENERGY</td>
        <td>
          PhotonEnergy<br />
          PhotonEnergy_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerThreshold</td>
        <td>
          detector/config/threshold_energy</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Energy threshold for the acquisition</td>
        <td>
          THRESHOLD</td>
        <td>
          Threshold<br />
          Threshold_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerTrigger</td>
        <td>
          detector/command/trigger</td>
        <td>
          asynInt32</td>
        <td>
          W/O</td>
        <td>
          Software trigger to be used on modes INTS and INTE when ManualTrigger is set</td>
        <td>
          TRIGGER</td>
        <td>
          Trigger</td>
        <td>
          ao</td>
      </tr>
      <tr>
        <td>
          EigerTriggerExp</td>
        <td>
          detector/command/trigger</td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Exposure to be used with the triggers on the INTE mode</td>
        <td>
          TRIGGER_EXPOSURE</td>
        <td>
          TriggerExposure<br />
          TriggerExposure_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerNTriggers</td>
        <td>
          detector/config/ntrigger</td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Number of triggers for the acquisition</td>
        <td>
          NUM_TRIGGERS</td>
        <td>
          NumTriggers<br />
          NumTriggers_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerManualTrigger</td>
        <td>
        </td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          On INTS and INTE modes, controls whether triggers will be issued automatically (0)
          or only via the Trigger PV (1). </td>
        <td>
          MANUAL_TRIGGER</td>
        <td>
          ManualTrigger<br />
          ManualTrigger_RBV</td>
        <td>
          bo<br />
          bi</td>
      </tr>
      <tr>
        <td>
          EigerCompressionAlgo</td>
        <td>
          detector/config/compression</td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Compression algorithm to use when compression is enabled. Options are:
          <ul>
            <li>lz4</li>
            <li>bslz4 (bitshuffle lz4)</li>
          </ul>
          The selected algorithm will always be used on the Stream ZMQ interface. It will
          also be used for HDF5 files written by the FileWriter interface if FWCompression=Enabled.
        </td>
        <td>
          COMPRESSION_ALGO</td>
        <td>
          CompressionAlgo<br />
          CompressionAlgo_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
      </tr>
      <tr>
        <td>
          EigerROIMode</td>
        <td>
          detector/config/roi_mode</td>
        <td>
          asynInt32</td>
        <td>
          R/W</td>
        <td>
          Which ROI mode to use. <b>Only supported on Eiger 9M and 16M.</b> Options are:
          <ul>
            <li>Disabled</li>
            <li>4M</li>
          </ul>
        </td>
        <td>
          ROI_MODE</td>
        <td>
          ROIMode<br />
          ROIMode_RBV</td>
        <td>
          mbbo<br />
          mbbi</td>
      </tr>
      <tr>
        <td align="center" colspan="8">
          <b>Minimum change allowed</b> </td>
      </tr>
      <tr>
        <td>
          EigerWavelengthEpsilon</td>
        <td>
        </td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Minimum amount of change allowed in Wavelength, in Angstroms.
        </td>
        <td>
          WAVELENGTH_EPSILON</td>
        <td>
          WavelengthEps<br />
          WavelengthEps_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
      <tr>
        <td>
          EigerEnergyEpsilon</td>
        <td>
        </td>
        <td>
          asynFloat64</td>
        <td>
          R/W</td>
        <td>
          Minimum amount of change allowed in PhotonEnergy, Theshold and Threshold2, in eV.
        </td>
        <td>
          ENERGY_EPSILON</td>
        <td>
          EnergyEps<br />
          EnergyEps_RBV</td>
        <td>
          ao<br />
          ai</td>
      </tr>
    </tbody>
  </table>
  <h2 id="Unsupported" style="text-align: left">
    Unsupported standard driver parameters</h2>
  <p>
    All standard parameters not mentioned in this document are not supported.</p>
  <h2 id="Configuration">
    Configuration</h2>
  <p>
    The Eiger driver is created with the eigerDetectorConfig command, either from C/C++
    or from the EPICS IOC shell.</p>
  <pre>int eigerDetectorConfig(const char *portName, const char *hostname,
                  int maxBuffers, size_t maxMemory, int priority, int stackSize)
    </pre>
  <p>
    For details on the meaning of the parameters to this function refer to the detailed
    documentation on the eigerDetectorConfig function in the <a href="areaDetectorDoxygenHTML/eiger_detector_8cpp.html">
      eigerDetector.cpp documentation</a> and in the documentation for the constructor
    for the <a href="areaDetectorDoxygenHTML/classeiger_detector.html">eigerDetector class</a>
  </p>
  <p>
    There an example IOC boot directory and startup script provided with areaDetector.
  </p>
  <h2 id="CSS_screen" style="text-align: left">
    medm screen</h2>
  <p>
    The following shows the medm screen that is used to control the Eiger detector.
    Note that the general purpose screen ADBase.adl can be used, but it exposes a few
    controls that are not applicable to the Eiger, and lacks some fields that are important
    for the Eiger.</p>
  <p>
    <code>eigerDetector.adl</code> is the screen used to control the Eiger driver.
  </p>
  <div style="text-align: center">
    <h3 style="text-align: center">
      eigerDetector,\adl</h3>
    <img alt="eiger.png" src="eiger.png" />
  </div>
  <h2 id="Known_Issues" style="text-align: left">
    Known Issues</h2>
  <h3 id="Changing_the_Photon_Energy">
    Changing the Photon Energy</h3>
  <p>
    Changing the Photon Energy is a potentially slow operation, depending on the detector
    size. On the 16M it takes around ten seconds. Other parameters also take this long
    because they also affect the Photon Energy, namely Threshold Energy and Wavelength.
    The StatusMessage PV indicates when setting any of these parameters start and finish.
  </p>
  <p>
    In order to prevent minute or accidental changes to Energy and Wavelength from taking
    too long to be applied, their values are only updated if the difference between the
    desired and current value is greater than some configurable parameters. Specifically,
    changes in Wavelength only take effect if they result in a difference greater than
    WavelengthEps (default: 0.0005 Angstroms). Similarly, changes to PhotonEnergy, Threshold
    and Threshold2 only take effect if they are greater than EnergyEps (default: 0.05 eV).
  </p>
  <h3 id="Status_Parameters_Polling">
    Status Parameters Polling</h3>
  <p>
    A few status parameters are read every time the ReadStatus PV is processed. A high
    rate polling causes issues, sometimes causing the detector to hang when, in conjunction,
    a parameter is set to an invalid value.
  </p>
  <h3 id="Internal_Enable_Mode">
    Internal Enable Mode</h3>
  <p>
    The Internal Enable mode is marked as experimental by Dectris. At the moment it
    is very flaky (firmware 1.5.0) and often doesn't generate all the files it is supposed
    to.
  </p>
</body>
</html>
